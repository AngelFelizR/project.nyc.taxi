# WARNING - Generated by {fusen} from dev/flat_functions.Rmd: do not edit by hand


#' Simulates a day of work
#' 
#' This function sample from a data.frame or arrow connection all the trips needed
#' to complete the a working day form taxi driver.
#'
#' @param arrow_con a data.frame or arrow connection with trips to sample from, with the columns described below.
#' @param start_datetime a date with an associated time when the taxi driver start to work
#' @param start_zone a number to select to the starting zone
#' @param minutes_next_trip an integer to define the limit time needed before extending the filters
#' @param end_datetime a date with an associated time when the taxi driver stop looking for new trips
#' @param valid_end_zones a vector of number defining all possible zones to drive
#' @param closest_zone a named vector pointing the closest zone from the taxi driver is waiting for a need trip in order to start a trip
#' @param borough_zones a data.frame with the integer column LocationID with all possible zone ids and the list column id_list with contain all other zones ids related to the LocationID's borough
#' 
#' @details
#' `arrow_con` must has the following columns
#' 
#' | "Column Name"| "class" |
#' |--------------|---------|
#' | year | integer |
#' | month| integer |
#' | PULocationID | integer|
#' | DOLocationID | integer|
#' | request_datetime | POSIXct POSIXt|
#' | dropoff_datetime | POSIXct POSIXt|
#' | driver_pay | numeric|
#' | tips | numeric|
#'
#' @importFrom lubridate minutes as_datetime make_datetime hours year month
#' @importFrom dplyr select filter compute collect slice_sample bind_rows
#' 
#' @return A data.frame
#' @export
#'
#' @examples
#'
#' # Defining some zone context
#' valid_zones <- 1:3
#' closest_zones <- c(2L, 1L, 2L)
#' names(closest_zones) <- valid_zones
#' borough_zones <- data.frame(
#'   LocationID = valid_zones,
#'   id_list = I(list(valid_zones, valid_zones, valid_zones))
#' )
#'
#' # Defining start point
#' start_datetime <- lubridate::make_datetime(2023L, 5L, 18L, 8L)
#' start_zone <- 1L
#'
#' # Let's check trips from at 3 levels
#' # 1. Starting in the same zone
#' # 2. Starting in the closest zone
#' # 3. Starting in the farthest zone
#' valid_trips <- data.frame(
#'   year = 2023L,
#'   month = 5L,
#'   PULocationID = c(1L, 2L, 3L),
#'   DOLocationID = c(3L, 1L, 1L),
#'   request_datetime = c(
#'    start_datetime + lubridate::minutes(2L),
#'    start_datetime + lubridate::minutes(20L + 7L),
#'    start_datetime + lubridate::minutes(37L + 14L)
#'   ),
#'   dropoff_datetime = c(
#'    start_datetime + lubridate::minutes(20L),
#'    start_datetime + lubridate::minutes(37L),
#'    lubridate::make_datetime(2023L, 5L, 18L, 9L, 1L)
#'   ),
#'   driver_pay = 10,
#'   tips = 2 
#' )
#'
#' simulate_trips(valid_trips,
#'                start_datetime = start_datetime,
#'                start_zone = start_zone,
#'                minutes_next_trip = 6L,
#'                end_datetime = start_datetime + lubridate::hours(1L),
#'                valid_end_zones = valid_zones,
#'                closest_zone = closest_zones,
#'                borough_zones = borough_zones)
#'
simulate_trips <- function(arrow_con,
                           start_datetime,
                           start_zone,
                           minutes_next_trip,
                           end_datetime,
                           valid_end_zones,
                           closest_zone,
                           borough_zones){
  
  expected_columns <- c(
    # Parquet document
    "year", "month",
    # Start and ending zones
    "PULocationID", "DOLocationID",
    # Start and ending date times
    "request_datetime", "dropoff_datetime",
    # Money related in the trip
    "driver_pay", "tips"
  )
  
  stopifnot("You are missing one or more expected column in the arrow_con" = 
              all(expected_columns %in% names(arrow_con)))
  
  
  # Transforming minutes to period class
  minutes_next_trip <- lubridate::minutes(minutes_next_trip)
  
  # For the first trip
  current_time <- start_datetime
  current_zone <- start_zone

  # An empty table to bind the results
  done_trips <- data.frame(
    s_PULocationID = vector("integer"),
    s_DOLocationID = vector("integer"),
    s_request_datetime = vector("double") |> lubridate::as_datetime(),
    s_dropoff_datetime = vector("double") |> lubridate::as_datetime(),
    s_driver_pay = vector("double"),
    s_tips = vector("double")
  )

  # We need to keep adding trips until reaching the end_time 
  while(current_time <= end_datetime){
  
  # Defining time needed to wait
  wait_limit_datetime <- current_time + minutes_next_trip

   # Filter all trips that meet the expected conditions
    # Remove any row that don't meet expectations
    simulated_trip <-
      arrow_con |>
      dplyr::filter(year == lubridate::year(current_time),
                    month == lubridate::month(current_time),
                    PULocationID %in% current_zone,
                    DOLocationID %in% valid_end_zones,
                    request_datetime >= current_time,
                    request_datetime <= wait_limit_datetime) |>
        
        # Add the prefix s_ to each column
        dplyr::select(s_PULocationID = PULocationID,
                      s_DOLocationID = DOLocationID,
                      s_request_datetime = request_datetime,
                      s_dropoff_datetime = dropoff_datetime,
                      s_driver_pay = driver_pay,
                      s_tips = tips)
    
    # If arrow we need to collect
    if(inherits(arrow_con, "ArrowObject")){
      
      simulated_trip <- dplyr::collect(simulated_trip)
    
    }
    
    # Once we have alternatives to select from can select one trip
    simulated_trip <- dplyr::slice_sample(simulated_trip, n = 1L) 

    # If we can not find any trip in the zone and time defined
    # we can move update the current time try to find trip in the closest zone
    if(length(current_zone) == 1L && nrow(simulated_trip) == 0L){

      current_time <- current_time + minutes_next_trip
      current_zone <- c(current_zone, closest_zone[as.character(current_zone)])

    # If we couldn't find any trip to the closest zone
    # we can open the trip to any zone of the borough
    # after updating the current_time
    }else if(length(current_zone) > 1L && nrow(simulated_trip) == 0L){

      current_time <- current_time + minutes_next_trip
      current_zone <- c(
        current_zone,
        borough_zones[borough_zones$LocationID == current_zone[1L], ][["id_list"]][[1L]]
      )

    }else{
      
      # Updating starting point for next trip
      current_time <- simulated_trip$s_dropoff_datetime
      current_zone <- simulated_trip$s_DOLocationID

      # Adding the trip to final result
      done_trips <- 
        dplyr::bind_rows(done_trips, simulated_trip)
      
    }

  }

  # Returning all trips
  return(done_trips)

}

