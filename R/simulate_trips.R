# WARNING - Generated by {fusen} from dev/flat_business_understending.Rmd: do not edit by hand


#' Simulates a day of work
#' 
#' This function sample from a data.frame or arrow connection all the trips needed
#' to complete the a working day form taxi driver.
#'
#' @param df a data.frame or arrow connection with trips to sample from
#' @param start_datetime a date with an associated time when the taxi driver start to work
#' @param start_zone a number to select to the starting zone
#' @param minutes_next_trip an integer to define the limit time needed before extending the filters
#' @param end_datetime a date with an associated time when the taxi driver stop looking for new trips
#' @param end_zones a vector of number defining all possible zones to drive
#' @param closest_zone a named vector pointing the closest zone from the taxi driver is waiting for a need trip in order to start a trip
#' @param borough_zones a data.frame with the integer column LocationID with all possible zone ids and the list column id_list with contain all other zones ids related to the LocationID's borough
#' @param seed_num a single value, interpreted as an integer to make possible to reproduce random events
#'
#' @importFrom lubridate minutes as_datetime
#' @importFrom dplyr select filter collect sample_n bind_rows
#'
#' @return A data.frame
#' @export
#'
simulate_trips <- function(df,
                           start_datetime,
                           start_zone,
                           minutes_next_trip,
                           end_datetime,
                           end_zones,
                           closest_zone,
                           borough_zones,
                           seed_num = 1234){
  
  # Confirm if will need to collect the results
  need_to_collect <- inherits(df, "Dataset")
  
  # Transforming minutes to period class
  minutes_next_trip <- lubridate::minutes(minutes_next_trip)
  
  # For the first trip
  current_time <- start_time
  current_zone <- start_zone

  # An empty table to bind the results
  done_trips <- data.frame(
    s_PULocationID = vector("integer"),
    s_DOLocationID = vector("integer"),
    s_request_datetime = vector("double") |> lubridate::as_datetime(),
    s_dropoff_datetime = vector("double") |> lubridate::as_datetime(),
    s_trip_miles = vector("double"),
    s_trip_time = vector("integer"),
    s_driver_pay = vector("double"),
    s_tips = vector("double")
  )

  # We need to keep adding trips until reaching the end_time 
  while(current_time <= end_time){

    # Filter all trips that meet the expected conditions
    trip_alternatives <-
     
      # From data source 
      df |>
      
      # Add the prefix s_ to each column
      dplyr::select(s_PULocationID = PULocationID,
                    s_DOLocationID = DOLocationID,
                    s_request_datetime = request_datetime,
                    s_dropoff_datetime = dropoff_datetime,
                    s_trip_miles = trip_miles,
                    s_trip_time = trip_time,
                    s_driver_pay = driver_pay,
                    s_tips = tips) |>
      
      # Remove any row that don't meet expectations
      dplyr::filter(s_PULocationID %in% current_zone &
                      s_DOLocationID %in% end_zones &
                      s_request_datetime >= current_time &
                      s_request_datetime <= (current_time + minutes_next_trip)) 
    
    
    # Collect the results if needed
    if(need_to_collect) {
      trip_alternatives <- dplyr::collect(trip_alternatives)
    }

    # If we can not find any trip in the zone and time defined
    # we can move update the current time try to find trip in the closest zone
    if(length(current_zone) == 1L && nrow(trip_alternatives) == 0L){

      current_time <- current_time + minutes_next_trip
      current_zone <- c(current_zone, closest_zone[as.character(current_zone)])

    # If we couldn't find any trip to the closest zone
    # we can open the trip to any zone of the borough
    # after updating the current_time
    }else if(length(current_zone) > 1L && nrow(trip_alternatives) == 0L){

      current_time <- current_time + minutes_next_trip
      current_zone <- c(
        current_zone,
        borough_zones[borough_zones$LocationID == 12L, ][["id_list"]][[1L]]
      )

    }else{

      # Once we have alternatives to select from can select one trip
      set.seed(seed_num)
      simulated_trip <- dplyr::sample_n(trip_alternatives, size = 1L)
      set.seed(NULL)
      
      # Updating starting point for next trip
      current_time <- simulated_trip$s_dropoff_datetime
      current_zone <- simulated_trip$s_DOLocationID

      # Adding the trip to final result
      done_trips <- dplyr::bind_rows(done_trips, simulated_trip)

    }

  }

  # Returning all trips
  return(done_trips)

}

