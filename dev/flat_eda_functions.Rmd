---
title: "flat_minimal_package.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.
-->

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# EDA functions

## arrow glimpse

```{r function-fast_glimpse}

#' glimpse for arrow connections
#' 
#' Shows the class related to each column without loading the data into memory. 
#'
#' @param x an arrow connection
#' 
#' @importFrom scales comma
#'
#' @return The schema related to the connection
#' @export
#'
#' @examples
fast_glimpse <- function(x){
  
  stopifnot("x is not an arrow connection" = 
              inherits(x, "ArrowObject") | inherits(x, "arrow_dplyr_query"))

  schm <- x$.data$schema

  col_types <- sapply(

    x$selected_columns,

    FUN = function(expr) {
      name <- expr$field_name
      if (nzchar(name)) {
        schm$GetFieldByName(name)$type$ToString()
      }
      else {
        expr$type(schm)$ToString()
      }

    })


  fields <- paste(
    names(col_types),
    col_types,
    sep = ": ",
    collapse = "\n"
  )

  cat(
    paste0("FileSystemDataset (query)\n",
           scales::comma(nrow(x)), " rows x ",
           scales::comma(ncol(x)), " columns\n\n",
           fields)
  )
  
  invisible(schm)
}

```


```{r example-fast_glimpse}

df <- data.frame(num = runif(10),
                 char = LETTERS[1:10],
                 factor = factor(LETTERS[1:10], levels = LETTERS[1:10]),
                 dates = seq(from = as.Date("2024-01-01"), 
                             by = "month", length.out = 10))

arrow::arrow_table(df) |> fast_glimpse()
```


```{r tests-fast_glimpse}

df <- data.frame(num = runif(10),
                 char = LETTERS[1:10],
                 factor = factor(LETTERS[1:10], levels = LETTERS[1:10]),
                 dates = seq(from = as.Date("2024-01-01"), 
                             by = "month", length.out = 10)) 

testthat::test_that("We don't method for data.frame",{
  testthat::expect_error(
    fast_glimpse(df)
  )
})

```


## count_pct

```{r function-count_pct}
#' Counts rows based con columns provided
#' 
#' It counts the number rows where each unique value repeated in the columns 
#' selected arranging there results in descent order and adds a percentage 
#' column after collecting the results from `arrow`.
#'
#' @param x A lazy data frame arrow connection.
#' @param ... Variables to group by
#' @param sort If TRUE, will show the largest groups at the top.
#' 
#' @importFrom dplyr count collect mutate
#' @importFrom rlang quos
#'
#' @return A data.frame
#' @export
#'
#' @examples
count_pct <- function(x, ..., sort = TRUE){
  
  grouping_vars_expr <- rlang::quos(...)

  dplyr::count(x, !!! grouping_vars_expr, sort = sort) |>
    dplyr::collect() |>
    dplyr::mutate(pct = n / sum(n))

}
```

```{r example-count_pct}
set.seed(1234)

arrow_con <- 
  data.frame(char1 = sample(LETTERS[1:3], 100, replace = TRUE),
             char2 = sample(LETTERS[4:6], 100, replace = TRUE)) |>
  arrow::arrow_table()

count_pct(arrow_con, char1)
count_pct(arrow_con, char2)
count_pct(arrow_con, char1, char2)
```


## join_zones

```{r function-join_zones}
#' Create a data.frame to show the zones
#' 
#' It creates the `start_borough`, `start_zone` and `start_service_zone` 
#' columns based on the `PULocationID` column and the `end_borough`, `end_zone` 
#' and `end_service_zone` columns based on the `DOLocationID` column.
#'
#' @param df A data.frame with all the code zones from main data.
#' @param zone_tb A data.frame with zones from data dictionary.
#' 
#' @importFrom data.table is.data.table `%chin%` uniqueN as.data.table
#'
#' @return A data.table
#' @export
join_zones <- function(df, zone_tb){
  
  # Validating that the tables has the columns needed
  stopifnot("df must have DOLocationID and PULocationID zone ids" = 
              all(c("DOLocationID", "PULocationID") %chin% names(df)))
  
  stopifnot("zone_tb must have LocationID, Borough, Zone and service_zone" = 
              all(c("LocationID", "Borough", "Zone", "service_zone") %chin% names(zone_tb)))
  
  # zone_tb can no have duplicated zones
  stopifnot("All zone_tb rows must be unique" = uniqueN(zone_tb$LocationID) == nrow(zone_tb))
  
  
  if(!data.table::is.data.table(df)){
    df <- data.table::as.data.table(df)
  }
  
  if(!data.table::is.data.table(zone_tb)){
    zone_tb <- data.table::as.data.table(zone_tb)
  }
  
  zone_tb[, .(end_id = LocationID,
              end_borough = Borough,
              end_zone = Zone,
              end_service_zone = service_zone)
  ][df, on = c("end_id" = "DOLocationID")
  ][, zone_tb[, .(start_id = LocationID,
                  start_borough = Borough,
                  start_zone = Zone,
                  start_service_zone = service_zone)
      ][.SD, on = c("start_id" = "PULocationID")
  ][, !c("start_id", "end_id")]]

}
```

## factor_weekday

```{r function-factor_weekday}
#' Transform number into factors
#'
#' Transform a numeric vector in factor with a level for each day of a week.
#'
#' @param x A numeric vector with values from 1 to 7
#'
#' @return A factor vector
#' @export
#'
#' @examples
factor_weekday <- function(x){
  
  stopifnot("The vector must be numeric" = is.numeric(x))
  
  if(!all(x %in% 1:7)){
    warning("One of the number is not from 1 to 7")
  }

  weekdays_name <- c("Mo", "Tu", "We", "Th", "Fr", "Sa", "Su")

  factor(weekdays_name[x], levels = weekdays_name)

}
```

```{r example-factor_weekday}

factor_weekday(c(1,7,5))

```


```{r test-factor_weekday}

test_that("x must be numeric",{
  testthat::expect_error(factor_weekday(c("Mon", 5)))
})

test_that("x must have values from 1 to 7",{
  testthat::expect_warning(factor_weekday(c(10, 5)))
})

```

## compute_boxplot

```{r function-compute_boxplot}
#' Calculates all values need to describe
#' 
#' Calculates of values needed to create a boxplot.
#'
#' @param x A data.frame or an arrow connection
#' @param value A column vector to summarize
#' 
#' @importFrom dplyr filter summarize mutate select collect
#'
#' @return A data.frame with summary values
#' @export
#'
#' @examples
compute_boxplot <- function(x, value){

  summary <-
    dplyr::filter(x,
                  !is.na({{value}})) |>
    dplyr::summarize(min_value = min({{value}}),
                     q1 = quantile({{value}}, 0.25),
                     q2 = median({{value}}),
                     q3 = quantile({{value}}, 0.75),
                     max_value = max({{value}})) |>
    dplyr::mutate(lower_whisker = q1 - 1.5*(q3 - q1),
                  higher_whisker = q3 + 1.5*(q3 - q1)) |>
    dplyr::select(min_value,
                  lower_whisker,
                  q1,
                  q2,
                  q3,
                  higher_whisker,
                  max_value)
  
  if(inherits(x, "ArrowObject") | inherits(x, "arrow_dplyr_query")){
    summary <- dplyr::collect(summary)
  }

  return(summary)
}
```


```{r example-compute_boxplot}

data.frame(x = rnorm(200, mean = 5)) |>
  arrow::arrow_table() |>
  compute_boxplot(x)

```


## show_boxplot

```{r function-show_boxplot}
#' Display boxplot chart based of a summary.
#'
#' @param x A data.frame
#' @param y_title A character value indicating the title to describe the y axis.
#' @param y_break_width A number to define the width related to y axis.
#' 
#' @importFrom ggplot2 ggplot geom_boxplot scale_y_continuous labs theme_light
#' @importFrom scales breaks_width
#'
#' @return A ggplot
#' @export
show_boxplot <- function(x, y_title = "", y_break_width = 2) {
  
  ggplot2::ggplot(x)+
    ggplot2::geom_boxplot(
      aes(x = "", y = q2,
          ymin = pmax(min_value, lower_whisker), 
          lower = q1, 
          middle = q2, 
          upper = q3, 
          ymax = pmin(max_value, higher_whisker)),
      stat = "identity",
      width = 0.3
    )+
    ggplot2::scale_y_continuous(breaks = scales::breaks_width(y_break_width))+
    ggplot2::labs(y = y_title,
                  x = "") +
    ggplot2::theme_light()
  
}
```


# Inflate the functions

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_eda_functions.Rmd", 
               vignette_name = NA,
               vignettes = FALSE)
```
