---
title: "Data Understanding"
output: 
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Data Understanding}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

After completing the [business understanding](https://angelfelizr.github.io/project.nyc.taxi/articles/02-business-understanding.html) phase we are ready to perform the **data understanding** phase by performing an EDA with the following steps:

1.  Exploring the individual distribution of variables.
2.  Exploring correlations between predictors and target variable.
3.  Exploring correlations between predictors.

As this will help to:
-   Ensure data quality
-   Identify key predictors
-   Detect multicollinearity
-   Guide model choice and feature engineering


## Setting the environment up

### Loading packages to use

```{r warning = FALSE, message = FALSE}
## Custom functions
library('project.nyc.taxi')

## To manage relative paths
library(here)

## To transform data larger than RAM
library(DBI)
library(duckdb)

## To transform data that fits in RAM
library(data.table)
library(lubridate)

## To create plots
library(ggplot2)
library(scales)

## Defining the print params to use in the report
options(datatable.print.nrows = 15, digits = 4)
```

### Creating DB connections

```{r}
con <- dbConnect(duckdb(), dbdir = here("my-db.duckdb"))

dbListTables(conn = con)
```

### Sampling data to use

As we have too much data will only need 1% of the data for training and testing the model, which corresponds to 3,272,947 rows between 2022 and 2023.

```r
ValidZoneSampleQuery <- glue::glue("
CREATE TABLE ValidZoneSample AS
SELECT t1.*
FROM NycTrips t1
INNER JOIN ZoneCodesFilter t2
  ON t1.PULocationID = t2.PULocationID AND
     t1.DOLocationID = t2.DOLocationID
USING SAMPLE 1% (system, 547548);
")

dbExecute(con, ValidZoneSampleQuery)
```

### Evaluate the performance

```{r}
ValidZoneSample <- dbGetQuery(con, "SELECT * FROM ValidZoneSample ORDER BY year, month")

setDT(ValidZoneSample)

ValidZoneSample =
  ValidZoneSample[, request_datetime_extra := request_datetime + minutes(15)
  # For computational limitations we will 
  # exclude trips that need to search in different months
  ][floor_date(request_datetime_extra, unit = "month") == 
      floor_date(request_datetime, unit = "month")]

SampleMonths <- ValidZoneSample[, .N, keyby = c("year", "month")]
```

```{r}
PointMeanDistance <- dbGetQuery(con, "SELECT * FROM PointMeanDistance")

setDT(PointMeanDistance)
```

```{r}
ParquetFiles <-
  here::here("raw-data", "trip-data") |>
  list.files(recursive = TRUE,
             full.names = TRUE) |>
  paste0("'", a = _ ,"'") |> 
  paste0("read_parquet([", a = _ ,"])")
```


```{r}
options(repos = c(CRAN = "https://cloud.r-project.org"))
utils::install.packages(c("future", "future.apply"))
plan(multisession, workers = 8)

results <-
  lapply(1:nrow(SampleMonths), \(month_i){
    
    ValidZoneSample_i <- ValidZoneSample[SampleMonths[month_i], on = c("year", "month")]
    NycTrips_i <- dbGetQuery(con,glue("SELECT * FROM {ParquetFiles[month_i]}"))
    setDT(NycTrips_i)
    
    
    # Step 1: Calculate waiting_secs and performance_per_hour for joined data
    trip_data <-
      lapply(1:nrow(ValidZoneSample_i), \(n_row){
        
        time_trips <-
          NycTrips_i[ValidZoneSample_i[n_row], 
                     on = "hvfhs_license_num"
          ][request_datetime >= i.request_datetime &
              request_datetime <= request_datetime_extra]
        
        current_trip_alternatives <-
          PointMeanDistance[.(ValidZoneSample_i$`PULocationID`[n_row]),
                            on = "PULocationID",
                            nomatch = NULL
          ][time_trips,
            on = c("DOLocationID" = "PULocationID"),
          ][, waiting_secs := as.numeric(difftime(request_datetime, i.request_datetime, units = "secs"))
          ][, performance_per_hour := (driver_pay + tips) / ((trip_time + waiting_secs) / 3600)
          ][(request_datetime <= i.request_datetime + 60 & trip_miles_mean <= 1) |
              (request_datetime <= i.request_datetime + 180 & trip_miles_mean <= 3) |
              (request_datetime <= i.request_datetime + 300 & trip_miles_mean <= 5) |
              (request_datetime <= i.request_datetime + 420 & trip_miles_mean <= 7) |
              (request_datetime <= i.request_datetime + 540 & trip_miles_mean <= 9) |
              (request_datetime <= i.request_datetime + 660 & trip_miles_mean <= 11) |
              (request_datetime <= i.request_datetime + 780 & trip_miles_mean <= 13) |
              (request_datetime <= i.request_datetime + 900 & trip_miles_mean <= 15) &
              ((i.wav_match_flag == 'Y' & wav_match_flag %in% c('Y', 'N')) |
                 (i.wav_match_flag == 'N' & wav_match_flag == 'N'))]
        
        return(current_trip_alternatives)
        
      }) |>
      rbindlist()
    
    # Step 2: Aggregate data by performance metrics
    aggregated_data <- trip_data[
      , .(percentile_75_performance = quantile(performance_per_hour, 0.75, na.rm = TRUE)),
      by = "trip_id"
    ]
    
    
    # Step 3: Join aggregated data with ValidZoneSample
    final_data <- 
      ValidZoneSample_i[aggregated_data, 
                        on = "trip_id"
      ][, take_current_trip := fifelse(performance_per_hour > percentile_75_performance, 0L, 1L)]
    
    
    # Result
    return(final_data[])
    
  })|>
  rbindlist()
```


```{r}
ValidZoneSamplePerformanceEvaluationQuery <- glue::glue("
CREATE TABLE ValidZoneSamplePerformanceEvaluation AS
WITH trip_data AS (
  SELECT 
    vz.hvfhs_license_num,
    vz.request_datetime AS vz_request_datetime,
    vz.PULocationID AS vz_PULocationID,
    vz.performance_per_hour AS vz_performance_per_hour,
    vz.wav_match_flag AS vz_wav_match_flag,
    t.request_datetime,
    t.trip_time,
    t.driver_pay,
    t.tips,
    pmd.trip_miles_mean,
    EXTRACT(EPOCH FROM (t.request_datetime - vz.request_datetime)) AS waiting_secs,
    (t.driver_pay + t.tips) / ((t.trip_time + EXTRACT(EPOCH FROM (t.request_datetime - vz.request_datetime))) / 3600) AS performance_per_hour
  FROM ValidZoneSample vz
  INNER JOIN NycTrips t
    ON t.hvfhs_license_num = vz.hvfhs_license_num
    AND t.request_datetime >= vz.request_datetime
    AND t.request_datetime <= vz.request_datetime + INTERVAL 15 MINUTE
  INNER JOIN PointMeanDistance pmd
    ON pmd.PULocationID = vz.PULocationID
    AND pmd.DOLocationID = t.PULocationID
  WHERE (
    (t.request_datetime <= vz.request_datetime + INTERVAL '1' MINUTE AND pmd.trip_miles_mean <= 1) OR
    (t.request_datetime <= vz.request_datetime + INTERVAL '3' MINUTE AND pmd.trip_miles_mean <= 3) OR
    (t.request_datetime <= vz.request_datetime + INTERVAL '5' MINUTE AND pmd.trip_miles_mean <= 5) OR
    (t.request_datetime <= vz.request_datetime + INTERVAL '7' MINUTE AND pmd.trip_miles_mean <= 7) OR
    (t.request_datetime <= vz.request_datetime + INTERVAL '9' MINUTE AND pmd.trip_miles_mean <= 9) OR
    (t.request_datetime <= vz.request_datetime + INTERVAL '11' MINUTE AND pmd.trip_miles_mean <= 11) OR
    (t.request_datetime <= vz.request_datetime + INTERVAL '13' MINUTE AND pmd.trip_miles_mean <= 13) OR
    (t.request_datetime <= vz.request_datetime + INTERVAL '15' MINUTE AND pmd.trip_miles_mean <= 15)
  )
  AND (
    (vz.wav_match_flag = 'Y' AND t.wav_match_flag IN ('Y', 'N'))
    OR (vz.wav_match_flag = 'N' AND t.wav_match_flag = 'N')
  )
),
aggregated_data AS (
  SELECT
    hvfhs_license_num,
    vz_request_datetime,
    vz_PULocationID,
    vz_performance_per_hour,
    vz_wav_match_flag,
    MAX(performance_per_hour) AS best_performance,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY performance_per_hour) AS median_performance,
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY performance_per_hour) AS percentile_75_performance
  FROM trip_data
  GROUP BY hvfhs_license_num, vz_request_datetime, vz_PULocationID, vz_performance_per_hour, vz_wav_match_flag
)
SELECT 
  vz.*,
  CASE 
    WHEN ad.percentile_75_performance <= vz.performance_per_hour 
    THEN 1 ELSE 0 END 
  AS take_current_trip
FROM ValidZoneSample vz
LEFT JOIN aggregated_data ad
  ON vz.hvfhs_license_num = ad.hvfhs_license_num
  AND vz.request_datetime = ad.vz_request_datetime
  AND vz.PULocationID = ad.vz_PULocationID
  AND vz.performance_per_hour = ad.vz_performance_per_hour
  AND vz.wav_match_flag = ad.vz_wav_match_flag                   
")

dbExecute(con, ValidZoneSamplePerformanceEvaluationQuery)
```

```{r}
dbGetQuery(con, "SELECT year, COUNT(*) AS n_rows 
                 FROM ValidZoneSamplePerformanceEvaluation GROUP BY year")
```


```{r}

TrainingSample |>
  ggplot(aes(performance_per_hour)) +
  geom_histogram() +
  scale_x_log10()

TrainingSample[,.(pay = cut_width(driver_pay + tips, 20),
                  performance_per_hour)] |>
  ggplot(aes(pay, performance_per_hour)) +
  geom_boxplot()
```

Aqui algunos ejemplos para calcular la variable predictiva

```r
# Definir la función de decisión
decidir_viaje <- function(tiempo_actual, duracion_actual, ganancia_actual, viajes_futuros) {
  
  # Calcular la ganancia por unidad de tiempo del viaje actual
  ganancia_por_tiempo_actual <- ganancia_actual / duracion_actual
  
  # Inicializar una variable para almacenar el mejor viaje futuro
  mejor_viaje_futuro <- NULL
  mejor_ganancia_futuro <- -Inf
  
  # Iterar sobre los viajes futuros
  for (viaje in viajes_futuros) {
    
    tiempo_futuro <- viaje$tiempo_inicio
    duracion_futuro <- viaje$duracion
    ganancia_futuro <- viaje$ganancia
    
    # Calcular el tiempo de espera hasta que empiece el viaje futuro
    tiempo_espera <- tiempo_futuro - (tiempo_actual + duracion_actual)
    
    # Si el tiempo de espera es negativo, el viaje futuro no es posible
    if (tiempo_espera >= 0) {
      
      # Calcular la ganancia por unidad de tiempo del viaje futuro
      ganancia_por_tiempo_futuro <- ganancia_futuro / (duracion_futuro + tiempo_espera)
      
      # Verificar si es mejor que el mejor viaje futuro encontrado hasta ahora
      if (ganancia_por_tiempo_futuro > mejor_ganancia_futuro) {
        mejor_ganancia_futuro <- ganancia_por_tiempo_futuro
        mejor_viaje_futuro <- viaje
      }
    }
  }
  
  # Comparar la ganancia del viaje actual con la del mejor viaje futuro
  if (!is.null(mejor_viaje_futuro) && mejor_ganancia_futuro > ganancia_por_tiempo_actual) {
    return(list("decision" = "esperar", "viaje_futuro" = mejor_viaje_futuro))
  } else {
    return(list("decision" = "aceptar", "viaje_actual" = list("tiempo" = tiempo_actual, 
                                                              "duracion" = duracion_actual, 
                                                              "ganancia" = ganancia_actual)))
  }
}

# Ejemplo de uso
viajes_futuros <- list(
  list(tiempo_inicio = 120, duracion = 30, ganancia = 50),
  list(tiempo_inicio = 150, duracion = 40, ganancia = 80)
)

resultado <- decidir_viaje(tiempo_actual = 100, duracion_actual = 20, ganancia_actual = 30, viajes_futuros = viajes_futuros)

print(resultado)

```


```sql
WITH ViajesActualesGanancia AS (
    -- Calculamos la ganancia por unidad de tiempo para los viajes actuales
    SELECT 
        id AS id_actual,
        tiempo_inicio AS tiempo_inicio_actual,
        duracion AS duracion_actual,
        ganancia AS ganancia_actual,
        ganancia / duracion AS ganancia_por_tiempo_actual
    FROM ViajesActuales
),
ViajesFuturosGanancia AS (
    -- Calculamos la ganancia por unidad de tiempo para los viajes futuros
    SELECT 
        id AS id_futuro,
        tiempo_inicio AS tiempo_inicio_futuro,
        duracion AS duracion_futuro,
        ganancia AS ganancia_futuro,
        ganancia / duracion AS ganancia_por_tiempo_futuro
    FROM ViajesFuturos
)
SELECT 
    v_actual.id_actual,
    v_actual.ganancia_por_tiempo_actual,
    v_futuro.id_futuro,
    v_futuro.ganancia_por_tiempo_futuro,
    v_futuro.tiempo_inicio_futuro - (v_actual.tiempo_inicio_actual + v_actual.duracion_actual) AS tiempo_espera_futuro,
    (ganancia_futuro / (duracion_futuro + (v_futuro.tiempo_inicio_futuro - (v_actual.tiempo_inicio_actual + v_actual.duracion_actual)))) AS ganancia_por_tiempo_ajustada_futuro
FROM 
    ViajesActualesGanancia v_actual
LEFT JOIN 
    ViajesFuturosGanancia v_futuro
ON 
    v_futuro.tiempo_inicio_futuro >= (v_actual.tiempo_inicio_actual + v_actual.duracion_actual)
-- Opcional: puedes filtrar solo por los viajes que superan en ganancia al viaje actual
WHERE 
    (ganancia_futuro / (duracion_futuro + (v_futuro.tiempo_inicio_futuro - (v_actual.tiempo_inicio_actual + v_actual.duracion_actual)))) > v_actual.ganancia_por_tiempo_actual
ORDER BY 
    id_actual, ganancia_por_tiempo_ajustada_futuro DESC
LIMIT 1;

```


