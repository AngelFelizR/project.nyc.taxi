# WARNING - Generated by {fusen} from dev/flat_business_understending.Rmd: do not edit by hand


#' Simulates a day of work
#' 
#' This function sample from a data.frame or arrow connection all the trips needed
#' to complete the a working day form taxi driver.
#'
#' @param df a data.frame or arrow connection with trips to sample from
#' @param start_datetime a date with an associated time when the taxi driver start to work
#' @param start_zone a number to select to the starting zone
#' @param minutes_next_trip an integer to define the limit time needed before extending the filters
#' @param end_datetime a date with an associated time when the taxi driver stop looking for new trips
#' @param valid_end_zones a vector of number defining all possible zones to drive
#' @param closest_zone a named vector pointing the closest zone from the taxi driver is waiting for a need trip in order to start a trip
#' @param borough_zones a data.frame with the integer column LocationID with all possible zone ids and the list column id_list with contain all other zones ids related to the LocationID's borough
#' @param seed_num a single value, interpreted as an integer to make possible to reproduce random events
#'
#' @importFrom lubridate minutes as_datetime make_datetime hours
#' @importFrom dplyr select filter collect sample_n bind_rows
#' @import arrow
#'
#' @return A data.frame
#' @export
#'
#' @examples
#'
#' # Let's defining 3 zones
#' valid_zones <- 1:3
#'
#' # Then define the closest zone to each zone
#' closest_zones <- c(2L, 1L, 2L)
#' names(closest_zones) <- valid_zones
#'
#' # All the zones are from the same borough
#' borough_zones <- data.frame(
#'   LocationID = valid_zones,
#'   id_list = I(list(valid_zones, valid_zones, valid_zones))
#' )
#'
#' start_datetime <- lubridate::make_datetime(2023L, 5L, 18L, 8L)
#' start_zone <- 1L
#'
#' df <- data.frame(
#'   PULocationID = c(
#'     
#'   # Let's simulate a trip in starting zone
#'   1L,
#'   
#'   # Then we can start in the closest zone
#'   2L,
#'   
#'   # Finally we can take a trip at borough level
#'   3L
#'   ),
#'   
#'   DOLocationID = c(3L, 1L, 1L),
#'   
#'   request_datetime = c(
#'    start_datetime + lubridate::minutes(2L),
#'    start_datetime + lubridate::minutes(20L + 7L),
#'    start_datetime + lubridate::minutes(37L + 14L)
#'   ),
#'   dropoff_datetime = c(
#'    start_datetime + lubridate::minutes(20L),
#'    start_datetime + lubridate::minutes(37L),
#'    lubridate::make_datetime(2023L, 5L, 18L, 9L, 1L)
#'   ),
#'   driver_pay = 10,
#'   tips = 2 
#' )
#'
#' df
#'
#' simulate_trips(df,
#'                start_datetime = start_datetime,
#'                start_zone = start_zone,
#'                minutes_next_trip = 6L,
#'                end_datetime = start_datetime + lubridate::hours(1L),
#'                valid_end_zones = valid_zones,
#'                closest_zone = closest_zones,
#'                borough_zones = borough_zones)
simulate_trips <- function(df,
                           start_datetime,
                           start_zone,
                           minutes_next_trip,
                           end_datetime,
                           valid_end_zones,
                           closest_zone,
                           borough_zones,
                           seed_num = 1234){
  
  # Confirm if will need to collect the results
  need_to_collect <- inherits(df, "Dataset")
  
  # Transforming minutes to period class
  minutes_next_trip <- lubridate::minutes(minutes_next_trip)
  
  # For the first trip
  current_time <- start_datetime
  current_zone <- start_zone

  # An empty table to bind the results
  done_trips <- data.frame(
    s_PULocationID = vector("integer"),
    s_DOLocationID = vector("integer"),
    s_request_datetime = vector("double") |> lubridate::as_datetime(),
    s_dropoff_datetime = vector("double") |> lubridate::as_datetime(),
    s_driver_pay = vector("double"),
    s_tips = vector("double")
  )

  # We need to keep adding trips until reaching the end_time 
  while(current_time <= end_datetime){

    # Filter all trips that meet the expected conditions
    trip_alternatives <-
     
      # From data source 
      df |>
      
      # Add the prefix s_ to each column
      dplyr::select(s_PULocationID = PULocationID,
                    s_DOLocationID = DOLocationID,
                    s_request_datetime = request_datetime,
                    s_dropoff_datetime = dropoff_datetime,
                    s_driver_pay = driver_pay,
                    s_tips = tips) |>
      
      # Remove any row that don't meet expectations
      dplyr::filter(s_PULocationID %in% current_zone &
                      s_DOLocationID %in% valid_end_zones &
                      s_request_datetime >= current_time &
                      s_request_datetime <= (current_time + minutes_next_trip)) 
    
    
    # Collect the results if needed
    if(need_to_collect) {
      trip_alternatives <- dplyr::collect(trip_alternatives)
    }

    # If we can not find any trip in the zone and time defined
    # we can move update the current time try to find trip in the closest zone
    if(length(current_zone) == 1L && nrow(trip_alternatives) == 0L){

      current_time <- current_time + minutes_next_trip
      current_zone <- c(current_zone, closest_zone[as.character(current_zone)])

    # If we couldn't find any trip to the closest zone
    # we can open the trip to any zone of the borough
    # after updating the current_time
    }else if(length(current_zone) > 1L && nrow(trip_alternatives) == 0L){

      current_time <- current_time + minutes_next_trip
      current_zone <- c(
        current_zone,
        borough_zones[borough_zones$LocationID == current_zone[1L], ][["id_list"]][[1L]]
      )

    }else{

      # Once we have alternatives to select from can select one trip
      set.seed(seed_num)
      simulated_trip <- dplyr::sample_n(trip_alternatives, size = 1L)
      set.seed(NULL)
      
      # Updating starting point for next trip
      current_time <- simulated_trip$s_dropoff_datetime
      current_zone <- simulated_trip$s_DOLocationID

      # Adding the trip to final result
      done_trips <- dplyr::bind_rows(done_trips, simulated_trip)

    }

  }

  # Returning all trips
  return(done_trips)

}

