# WARNING - Generated by {fusen} from dev/flat_business_understending.Rmd: do not edit by hand


#' Simulates a day of work
#' 
#' This function sample from a data.frame or arrow connection all the trips needed
#' to complete the a working day form taxi driver.
#'
#' @param arrow_con an arrow connection with trips to sample from
#' @param start_datetime a date with an associated time when the taxi driver start to work
#' @param start_zone a number to select to the starting zone
#' @param minutes_next_trip an integer to define the limit time needed before extending the filters
#' @param end_datetime a date with an associated time when the taxi driver stop looking for new trips
#' @param valid_end_zones a vector of number defining all possible zones to drive
#' @param closest_zone a named vector pointing the closest zone from the taxi driver is waiting for a need trip in order to start a trip
#' @param borough_zones a data.frame with the integer column LocationID with all possible zone ids and the list column id_list with contain all other zones ids related to the LocationID's borough
#'
#' @importFrom lubridate minutes as_datetime make_datetime hours year month
#' @importFrom dplyr select filter compute collect slice_sample
#' @importFrom arrow concat_tables schema int64 timestamp
#' 
#' @return A data.frame
#' @export
#'
#' @examples
#'
#' # Let's defining 3 zones
#' valid_zones <- 1:3
#'
#' # Then define the closest zone to each zone
#' closest_zones <- c(2L, 1L, 2L)
#' names(closest_zones) <- valid_zones
#'
#' # All the zones are from the same borough
#' borough_zones <- data.frame(
#'   LocationID = valid_zones,
#'   id_list = I(list(valid_zones, valid_zones, valid_zones))
#' )
#'
#' start_datetime <- lubridate::make_datetime(2023L, 5L, 18L, 8L)
#' start_zone <- 1L
#'
#' ArrowDf <- data.frame(
#'   year = 2023L,
#'   month = 5L,
#'   PULocationID = c(
#'     
#'   # Let's simulate a trip in starting zone
#'   1L,
#'   
#'   # Then we can start in the closest zone
#'   2L,
#'   
#'   # Finally we can take a trip at borough level
#'   3L
#'   ),
#'   
#'   DOLocationID = c(3L, 1L, 1L),
#'   
#'   request_datetime = c(
#'    start_datetime + lubridate::minutes(2L),
#'    start_datetime + lubridate::minutes(20L + 7L),
#'    start_datetime + lubridate::minutes(37L + 14L)
#'   ),
#'   dropoff_datetime = c(
#'    start_datetime + lubridate::minutes(20L),
#'    start_datetime + lubridate::minutes(37L),
#'    lubridate::make_datetime(2023L, 5L, 18L, 9L, 1L)
#'   ),
#'   driver_pay = 10,
#'   tips = 2 
#' ) |>
#'   arrow::arrow_table(schema = arrow::schema(
#'     year = arrow::int32(),
#'     month = arrow::int32(),
#'     PULocationID = arrow::int64(),
#'     DOLocationID = arrow::int64(),
#'     request_datetime = arrow::timestamp(unit = "us"),
#'     dropoff_datetime = arrow::timestamp(unit = "us"),
#'     driver_pay = double(),
#'     tips = double()
#'   ))
#'
#'
#' simulate_trips(ArrowDf,
#'                start_datetime = start_datetime,
#'                start_zone = start_zone,
#'                minutes_next_trip = 6L,
#'                end_datetime = start_datetime + lubridate::hours(1L),
#'                valid_end_zones = valid_zones,
#'                closest_zone = closest_zones,
#'                borough_zones = borough_zones) |>
#'   dplyr::collect()
#'
simulate_trips <- function(arrow_con,
                           start_datetime,
                           start_zone,
                           minutes_next_trip,
                           end_datetime,
                           valid_end_zones,
                           closest_zone,
                           borough_zones){
  
  # Confirm if will need to compute the results
  stopifnot("arrow_con is not an arrow connection" = inherits(arrow_con, "ArrowObject"))
  
  # Transforming minutes to period class
  minutes_next_trip <- lubridate::minutes(minutes_next_trip)
  
  # For the first trip
  current_time <- start_datetime
  current_zone <- start_zone

  # An empty table to bind the results
  done_trips <- data.frame(
    s_PULocationID = vector("integer"),
    s_DOLocationID = vector("integer"),
    s_request_datetime = vector("double") |> lubridate::as_datetime(),
    s_dropoff_datetime = vector("double") |> lubridate::as_datetime(),
    s_driver_pay = vector("double"),
    s_tips = vector("double")
  ) |>
    arrow::arrow_table(schema = arrow::schema(
      s_PULocationID = arrow::int64(),
      s_DOLocationID = arrow::int64(),
      s_request_datetime = arrow::timestamp(unit = "us"),
      s_dropoff_datetime = arrow::timestamp(unit = "us"),
      s_driver_pay = double(),
      s_tips = double()
    ))

  # We need to keep adding trips until reaching the end_time 
  while(current_time <= end_datetime){
  
  # Defining time needed to wait
  wait_limit_datetime <- current_time + minutes_next_trip

   # Filter all trips that meet the expected conditions
    # Remove any row that don't meet expectations
    simulated_trip <-
      arrow_con |>
      dplyr::filter(year == lubridate::year(current_time),
                    month == lubridate::month(current_time),
                    PULocationID %in% current_zone,
                    DOLocationID %in% valid_end_zones,
                    request_datetime >= current_time,
                    request_datetime <= wait_limit_datetime) |>
      
        # Once we have alternatives to select from can select one trip
        dplyr::slice_sample(n = 1L) |>
        
        # Add the prefix s_ to each column
        dplyr::select(s_PULocationID = PULocationID,
                      s_DOLocationID = DOLocationID,
                      s_request_datetime = request_datetime,
                      s_dropoff_datetime = dropoff_datetime,
                      s_driver_pay = driver_pay,
                      s_tips = tips) |>
      
      dplyr::compute()

    # If we can not find any trip in the zone and time defined
    # we can move update the current time try to find trip in the closest zone
    if(length(current_zone) == 1L && nrow(simulated_trip) == 0L){

      current_time <- current_time + minutes_next_trip
      current_zone <- c(current_zone, closest_zone[as.character(current_zone)])

    # If we couldn't find any trip to the closest zone
    # we can open the trip to any zone of the borough
    # after updating the current_time
    }else if(length(current_zone) > 1L && nrow(simulated_trip) == 0L){

      current_time <- current_time + minutes_next_trip
      current_zone <- c(
        current_zone,
        borough_zones[borough_zones$LocationID == current_zone[1L], ][["id_list"]][[1L]]
      )

    }else{
      
      # Updating starting point for next trip
      current_time <- as.vector(simulated_trip$s_dropoff_datetime)
      current_zone <- as.vector(simulated_trip$s_DOLocationID)

      # Adding the trip to final result
      done_trips <- arrow::concat_tables(done_trips, simulated_trip)
      
    }

  }

  # Returning all trips
  return(done_trips)

}

