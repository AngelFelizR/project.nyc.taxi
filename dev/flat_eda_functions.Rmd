---
title: "flat_minimal_package.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.
-->

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# arrow glimpse

```{r function-fast_glimpse}

#' glimpse for arrow connections
#' 
#' Shows the class related to each column without loading the data into memory. 
#'
#' @param x an arrow connection
#' 
#' @importFrom scales comma
#'
#' @return The schema related to the connection
#' @export
#'
#' @examples
fast_glimpse <- function(x){
  
  stopifnot("x is not an arrow connection" = inherits(x, "ArrowObject"))

  schm <- x$.data$schema

  col_types <- sapply(

    x$selected_columns,

    FUN = function(expr) {
      name <- expr$field_name
      if (nzchar(name)) {
        schm$GetFieldByName(name)$type$ToString()
      }
      else {
        expr$type(schm)$ToString()
      }

    })


  fields <- paste(
    names(col_types),
    col_types,
    sep = ": ",
    collapse = "\n"
  )

  cat(
    paste0("FileSystemDataset (query)\n",
           scales::comma(nrow(x)), " rows x ",
           scales::comma(ncol(x)), " columns\n\n",
           fields)
  )
  
  invisible(schm)
}

```


```{r example-fast_glimpse}

df <- data.frame(num = runif(10),
                 char = LETTERS[1:10],
                 factor = factor(LETTERS[1:10], levels = LETTERS[1:10]),
                 dates = seq(from = as.Date("2024-01-01"), 
                             by = "month", length.out = 10))

arrow::arrow_table(df) |> fast_glimpse()
```


```{r tests-fast_glimpse}

df <- data.frame(num = runif(10),
                 char = LETTERS[1:10],
                 factor = factor(LETTERS[1:10], levels = LETTERS[1:10]),
                 dates = seq(from = as.Date("2024-01-01"), 
                             by = "month", length.out = 10)) 

testthat::test_that("We don't method for data.frame",{
  testthat::expect_error(
    fast_glimpse(df)
  )
})

```


# count_pct

```{r function-count_pct}
#' Counts rows based con columns provided
#' 
#' It counts the number rows where each unique value repeated in the columns 
#' selected arranging there results in descent order and adds a percentage 
#' column after collecting the results from `arrow`.
#'
#' @param x A lazy data frame arrow connection.
#' @param ... Variables to group by
#' @param sort If TRUE, will show the largest groups at the top.
#' 
#' @importFrom dplyr count collect mutate
#'
#' @return A data.frame
#' @export
#'
#' @examples
count_pct <- function(x, ..., sort = TRUE){

  dplyr::count(x, ..., sort = sort) |>
    dplyr::collect() |>
    dplyr::mutate(pct = n / sum(n))

}
```

```{r example-count_pct}
set.seed(1234)

arrow_con <- 
  data.frame(char1 = sample(LETTERS[1:3], 100, replace = TRUE),
             char2 = sample(LETTERS[4:6], 100, replace = TRUE)) |>
  arrow::arrow_table()

count_pct(arrow_con, char1)
count_pct(arrow_con, char2)
count_pct(arrow_con, char1, char2)
```


# join_zones

```{r}
#' Create a data.frame to show the zones
#' 
#' It creates the `start_borough`, `start_zone` and `start_service_zone` 
#' columns based on the `PULocationID` column and the `end_borough`, `end_zone` 
#' and `end_service_zone` columns based on the `DOLocationID` column.
#'
#' @param x A data.frame with all the code zones from main data.
#' @param zone_tb A data.frame with zones from data dictionary.
#' 
#' @importFrom data.table is.data.table data:table
#'
#' @return A data.table
#' @export
#'
#' @examples
join_zones <- function(x, zone_tb){
  
  if(!data:table::is.data.table(x)){
    x <- data:table::as.data.table(x)
  }
  
  if(!data:table::is.data.table(zone_tb)){
    zone_tb <- data:table::as.data.table(zone_tb)
  }
  
  zone_tb[, .(end_id = LocationID,
              end_borough = Borough,
              end_zone = Zone,
              end_service_zone = service_zone)
  ][x, on = c("end_id" = "DOLocationID")
  ][, zone_tb[, .(start_id = LocationID,
                  start_borough = Borough,
                  start_zone = Zone,
                  start_service_zone = service_zone)
  ][.SD, on = c("start_id" = "PULocationID")
  ][, !c("start_id", "end_id")]]

}
```

# Inflate the functions

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_eda_functions.Rmd", 
               vignette_name = NA,
               vignettes = FALSE)
```
