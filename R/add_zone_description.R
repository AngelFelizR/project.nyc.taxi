# WARNING - Generated by {fusen} from dev/flat_functions.Rmd: do not edit by hand

#' Create a data.frame to show the zones
#' 
#' It translate the start and end ids with more detailed information.
#'
#' @param dt Main data.table to be use.
#' @param zone_dt A data.table with zones from data dictionary.
#' @param start_id_col A string indicating the id to be used as starting point.
#' @param end_id_col A string indicating the id to be used as ending point.
#' @param keep_dt_id_cols If `FALSE`, the columns indicated the `start_id_col` and `end_id_col` will be removed.
#' @param zone_id_col A string indicating the id related to each location in the `zone_dt` table.
#' 
#' @return A data.table
#' @export
#' @examples
#' set.seed(123)
#'
#' base_data <- data.table::data.table(
#'   start_id = 1:5,
#'   end_id = sample.int(5, 5),
#'   value = seq(50, length.out = 5, by = 50)
#' )
#'
#' zone_description <- data.table::data.table(
#'   id = 1:5,
#'   City = LETTERS[1:5],
#'   Zone = tail(LETTERS, 5L)
#' )
#'
#' add_zone_description(base_data,
#'                      zone_description,
#'                      start_id_col = "start_id",
#'                      end_id_col = "end_id",
#'                      zone_id_col = "id")
add_zone_description <- function(dt, 
                                 zone_dt,
                                 start_id_col,
                                 end_id_col,
                                 zone_id_col,
                                 keep_dt_id_cols = FALSE){
  
  ## assertive programming
  
  # Validate if any col name is missing
  stopifnot("start_id_col must be length 1 character vector" =
              length(start_id_col) == 1L && is.character(start_id_col))
  stopifnot("end_id_col must be length 1 character vector" =
              length(end_id_col) == 1L && is.character(end_id_col))
  stopifnot("zone_id_col must be length 1 character vector" =
              length(zone_id_col) == 1L && is.character(zone_id_col))
  
  # Data must be formatted in data.tables
  stopifnot("dt must be a data.table" = data.table::is.data.table(dt))
  stopifnot("zone_dt must be a data.table" = data.table::is.data.table(zone_dt))
  
  # Validating that the tables has the columns needed
  stopifnot("dt must have start_id_col and end_id_col columns" = all(c(start_id_col, end_id_col) %chin% names(dt)))
  stopifnot("zone_dt must have zone_id_col" = zone_id_col %chin% names(zone_dt))
  
  # zone_dt can no have duplicated zones
  stopifnot("All zone_dt rows must be unique" = uniqueN(zone_dt[[zone_id_col]]) == nrow(zone_dt))

  ## Copying the data to avoid side effects
  zone_tb_end <- data.table::copy(zone_dt)
  zone_tb_start <- data.table::copy(zone_dt)
  
  ## Changing zone_td col names
  
  # Changing id column
  data.table::setnames(zone_tb_end, zone_id_col, "end_id")
  data.table::setnames(zone_tb_start, zone_id_col, "start_id")
  
  # Adding the correct prefix the remaining columns
  remaining_cols <- names(zone_tb_end)[-1]
  remaining_cols_lower <- tolower(remaining_cols)
  data.table::setnames(zone_tb_end, 
                       remaining_cols,
                       paste0("end_", remaining_cols_lower))
  data.table::setnames(zone_tb_start,
                       remaining_cols,
                       paste0("start_", remaining_cols_lower))
  
  
  ## Creating the table to export
  
  # Adding ending information
  joined_dt <- zone_tb_end[dt, on = c("end_id" = end_id_col)]
  joined_dt <- zone_tb_start[joined_dt, on = c("start_id" = start_id_col)]
  
  # Dealing with col id names
  if(keep_dt_id_cols){
    
    # Restoring col id names
    data.table::setnames(joined_dt,
                         c("start_id", "end_id"),
                         c(start_id_col, end_id_col))
    
  }else{
    
    # Removing original id columns
    joined_dt[, c("start_id", "end_id") := NULL]
    
  }
  
  return(joined_dt[])

}
